class AhoCorasickNode
{
    constructor(symbol = null, parentNode = null)
    {
        this.next = [];
        this.symbol = symbol;
        this.parentNode = parentNode;
        this.suffixLink = null;
        this.count = 0;
    }

    markAsRoot()
    {
        this.suffixLink = this;
    }

    addNextSymbol(symbol)
    {
        if (!this.next[symbol])
        {
            this.next[symbol] = new AhoCorasickNode(symbol, this);
        }

        return this.next[symbol];
    }

    computeSuffixLink(rootNode)
    {
        if (this === rootNode)
        {
            throw new Error("[Internal] Can't compute the sufix link of the root node!");   
        }

        // Start from the suffix link of the parent node
        let failNode = this.parentNode.suffixLink;

        // Keep following the suffix links until the current node has a route marked by the symbol of the current node.
        while (failNode !== rootNode && !failNode.next[this.symbol])
        {
            // If possible, it will start from the suffix of the parrent node. ex: 'abcdef' => 'def'.
            // Otherwise it will keep checking the following suffix links. ex: 'ef' and 'f' until a valid node is found (or the root is reached)
            failNode = failNode.suffixLink;
        }

        // If there is route marked by the current symbol.
        if (failNode !== this.parentNode && failNode.next[this.symbol])
        {
            // Go to the next node.
            failNode = failNode.next[this.symbol];
        }

        // The link to the longest valid suffix (or root).
        this.suffixLink = failNode;
    }
}

class AhoCorasick
{
    constructor()
    {
        this.root = new AhoCorasickNode(null, null);
        this.root.markAsRoot();
        this.treeLeafs = [];
        this.queue = [];
        this.pristine = true;
    }

    addWord(strWord)
    {
        let _currentNode = this.root;

        for (const symbol of strWord)
        {
            // build the basic trie nodes
            _currentNode = _currentNode.addNextSymbol(symbol);
        }

        // save the edge node of every word
        this.treeLeafs.push(_currentNode);
    }

    _addToQueue(_ahoCorasickNode)
    {
        this.queue.push(_ahoCorasickNode);
    }

    prepareAutomaton()
    {
        let _start = 0;

        // start a breadth-first search (BFS) from the root node
        this._addToQueue(this.root);

        while (_start !== this.queue.length)
        {
            const currentNode = this.queue[_start];
            _start += 1;

            if (currentNode !== this.root)
            {
                // compute the fail node link for the current node
                currentNode.computeSuffixLink(this.root);
            }

            for (const nextNode of Object.values(currentNode.next))
            {
                // add the children of the current node to the qeueue
                this._addToQueue(nextNode);
            }
        }
    }

    _clearCounters()
    {
        for (let index = this.queue.length - 1; index >= 0; --index)
        {
            const currentNode = this.queue[index];
            currentNode.count = 0;
        }
    }

    matchText(strText)
    {
        if (this.pristine !== true)
        {
            // Clear the counters generated by the previous call.
            this._clearCounters();
        }

        // Marks the state as not pristine (used).
        this.pristine = false;

        // We start from the root of the trie.
        let currentNode = this.root;

        for (const symbol of strText)
        {
            // Find the first node in automaton (starting from the current node) that has a route marked by the current symbol.
            while (!currentNode.next[symbol] && currentNode !== this.root)
            {
                // If the current node doesn't have the desired route,
                // it will try again from it's fail node.
                currentNode = currentNode.suffixLink;
            }

            // If there is a route marked by the current symbol
            if (currentNode.next[symbol])
            {
                currentNode = currentNode.next[symbol];
            }

            // Update the passage through this node.
            currentNode.count += 1;
        }

        // Iterate through the previously created queue (BFS) from the end to the root.
        // This order is important to ensure that we never have to go through the same node multiple times.
        for (let index = this.queue.length - 1; index >= 0; --index)
        {
            const currentNode = this.queue[index];

            // If there is a fallback, it will inherit the number of symbol stops of the current node.
            if (currentNode.suffixLink && currentNode.suffixLink !== this.root)
            {
                // ex: 'bc' will appear every time 'abc' appears
                // and  'c' will appear every time 'abc' or 'bc' appears.
                currentNode.suffixLink.count += currentNode.count;
            }
        }

        // return the number of stops for each of our words
        return this.treeLeafs.map((ahoCorasickNode) => ahoCorasickNode.count);
    }
}

module.exports = AhoCorasick;